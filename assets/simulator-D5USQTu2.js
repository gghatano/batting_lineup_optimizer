import{c as O}from"./index-CITNQnHO.js";const T=t=>{const e=t.打席数||1,l=Math.max(0,t.安打-t.二塁打-t.三塁打-t.本塁打)/e,s=t.二塁打/e,a=t.三塁打/e,n=t.本塁打/e,o=(t.四球+t.死球)/e,i=t.三振/e,c=l+s+a+n+o+i,d=Math.max(0,1-c);return[{type:"homerun",probability:n,bases:4},{type:"triple",probability:a,bases:3},{type:"double",probability:s,bases:2},{type:"single",probability:l,bases:1},{type:"walk",probability:o,bases:1},{type:"strikeout",probability:i,bases:0},{type:"out",probability:d,bases:0}]},A=t=>{const e=new Float32Array(t.length);let l=0;for(let n=0;n<t.length;n++){const o=t[n];o&&(l+=o.probability,e[n]=l)}const s=e.length-1,a=s>=0?e[s]:0;if(a&&a>0)for(let n=0;n<e.length;n++)e[n]/=a;return e},I=(t,e,l)=>{let s=0,a=e.length-1;for(;s<a;){const n=Math.floor((s+a)/2);t<=e[n]?a=n:s=n+1}return l[s]||{type:"out",probability:1,bases:0}},v=(t,e,l)=>{const s=O(t.runners,e,l);return t.runners=s.newRunners,s.runs},F=(t,e,l,s,a=!1)=>{let n=0,o=0,i=s;const c={runners:0},d=[];for(;o<3;){const h=e[i],b=l[i];if(!h||!b)break;const y=Math.random(),m=I(y,b,h);let f=0,u=!1;m.type==="strikeout"||m.type==="out"?(o++,f=v(c,m.type,o-1)):(f=v(c,m.type,o),m.type==="homerun"&&(u=!0)),n+=f,a&&d.push({playerIndex:i,result:m.type,scored:u,rbis:f}),i=(i+1)%9}return{runs:n,newBatterIndex:i,playerActions:a?d:void 0}},k=(t,e,l,s=!1,a)=>{let n=0,o=0,i=0;const c=[],d=t.map((h,b)=>({playerIndex:b,atBats:0,hits:0,runs:0,rbis:0}));for(let h=0;h<9;h++){const{runs:b,newBatterIndex:y,playerActions:m}=F(t,e,l,o,s);n+=b,c.push(b),o=y,s&&m&&m.forEach(f=>{const u=d[f.playerIndex];u&&(u.atBats+=1,["single","double","triple","homerun"].includes(f.result)&&(u.hits+=1),f.scored&&(u.runs+=1),u.rbis+=f.rbis||0)}),i+=3}return i<27&&console.warn(`⚠️ 異常に少ない打席数: ${i}打席, 得点: ${n}`),s&&a!==void 0?{gameNumber:a,totalScore:n,inningScores:c,playerStats:d}:n},B=async(t,e,l)=>{const s=performance.now();console.log(`🚀 Monte-Carloシミュレーション開始: ${e.numberOfGames}試合`);const a=t.map(T),n=a.map(A);console.log(`📊 確率テーブル生成完了: ${t.length}選手`),console.log("🎲 最初の選手の確率例: ",a[0]);const o=[],i=Math.max(100,Math.min(1e3,Math.floor(e.numberOfGames/100)));console.log(`📊 プログレス更新間隔: ${i}試合ごと`),console.log(`🎮 ゲームループ開始: ${e.numberOfGames}試合`),l&&(console.log("🚀 初回プログレス更新送信"),l({completedGames:0,totalGames:e.numberOfGames,progress:0,currentAverage:0}));const c=e.numberOfGames<=1e3,d=[];for(let r=0;r<e.numberOfGames;r++){const g=performance.now(),$=k(t,a,n,c,r+1),M=performance.now()-g;if(c&&typeof $=="object"?(d.push($),o.push($.totalScore)):o.push($),r<10){const p=c&&typeof $=="object"?$.totalScore:$;console.log(`🏆 試合${r+1}: ${p}点 (${M.toFixed(2)}ms)`)}if((r+1)%100===0){const p=(performance.now()-s)/(r+1);console.log(`⏱️ 100試合経過: 平均ゲーム時間 ${p.toFixed(3)}ms`)}if(l&&(r+1)%i===0){const p=o.reduce((G,S)=>G+S,0)/o.length,w=(r+1)/e.numberOfGames;console.log(`📈 進捗: ${(w*100).toFixed(1)}% (${r+1}/${e.numberOfGames}試合), 平均: ${p.toFixed(2)}点`),l({completedGames:r+1,totalGames:e.numberOfGames,progress:w,currentAverage:p,simulationId:e.simulationId})}if((r+1)%1e3===0){const p=o.reduce((w,G)=>w+G,0)/o.length;console.log(`🎯 中間結果 ${r+1}試合: 平均${p.toFixed(2)}点`)}r%1e3===0&&r>0&&await new Promise(p=>setTimeout(p,0))}const b=performance.now()-s;console.log(`⏱️ シミュレーション実行時間: ${b.toFixed(0)}ms`),console.log(`🎯 全${e.numberOfGames}試合完了`);const y=o.reduce((r,g)=>r+g,0)/o.length,m=o.reduce((r,g)=>r+Math.pow(g-y,2),0)/o.length,f=Math.sqrt(m);let u=o[0]||0,x=o[0]||0;for(let r=1;r<o.length;r++){const g=o[r];g<u&&(u=g),g>x&&(x=g)}return console.log(`📊 最終統計: 平均${y.toFixed(2)}点, 範囲${u}-${x}点, 標準偏差${f.toFixed(2)}`),console.log(`⚡ パフォーマンス: ${(e.numberOfGames/(b/1e3)).toFixed(0)}試合/秒`),{averageScore:y,variance:m,standardDeviation:f,minScore:u,maxScore:x,totalGames:e.numberOfGames,scores:o,executionTime:b,gameDetails:c?d:void 0,hasDetailedData:c}};self.onmessage=async t=>{const{lineup:e,params:l}=t.data;try{const s=await B(e,l,a=>{self.postMessage({type:"progress",payload:a})});self.postMessage({type:"complete",payload:s})}catch(s){self.postMessage({type:"error",payload:s instanceof Error?s.message:"Unknown error"})}};export{B as runMonteCarloSimulation};
